#!/usr/bin/env python3
"""
Contract Intelligence API - Supplier-Perspective Contract Analysis
Auto-generated by vps-deployment skill for Hostinger VPS.

Analyzes contracts (NDAs, T&Cs, MSAs) from supplier perspective,
returning stoplight risk assessment and redline recommendations.
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
import sqlite3
from datetime import datetime
import os
import json
import httpx
import asyncio

app = FastAPI(
    title="Contract Intelligence API",
    description="Supplier-perspective contract risk analysis with stoplight scoring and redline recommendations",
    version="1.0.0"
)

# CORS for Electron app access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configuration
ANTHROPIC_API_KEY = os.environ.get("ANTHROPIC_API_KEY", "")
DB_PATH = os.environ.get("DATA_PATH", "/opt/skills-data/contract-intelligence/metrics.db")

# Risk patterns library (supplier perspective)
RISK_PATTERNS = {
    "payment_terms": {
        "high_risk": ["net 90", "net 120", "payment upon resale", "pay when paid"],
        "medium_risk": ["net 60", "payment upon acceptance"],
        "description": "Extended payment terms increase cash flow risk"
    },
    "indemnification": {
        "high_risk": ["unlimited indemnification", "indemnify and hold harmless without limitation", "sole liability"],
        "medium_risk": ["broad indemnification", "third party claims"],
        "description": "Uncapped indemnification exposes supplier to unlimited liability"
    },
    "limitation_of_liability": {
        "high_risk": ["no limitation", "unlimited liability", "waive all limitations"],
        "medium_risk": ["exceeds contract value", "consequential damages included"],
        "description": "Missing or weak liability caps create existential risk"
    },
    "termination": {
        "high_risk": ["terminate for convenience immediately", "terminate without notice", "terminate without cause"],
        "medium_risk": ["30 day termination", "cure period less than 15 days"],
        "description": "Asymmetric termination rights favor buyer"
    },
    "ip_rights": {
        "high_risk": ["all ip belongs to buyer", "work for hire", "assign all rights", "perpetual license"],
        "medium_risk": ["broad license grant", "derivative works"],
        "description": "IP assignment without fair compensation"
    },
    "warranty": {
        "high_risk": ["unlimited warranty", "warranty period exceeds 24 months", "warrant fitness for purpose"],
        "medium_risk": ["12-24 month warranty", "implied warranties not disclaimed"],
        "description": "Extended warranty obligations increase long-term risk"
    },
    "confidentiality": {
        "high_risk": ["perpetual confidentiality", "survive indefinitely", "no time limit"],
        "medium_risk": ["confidentiality exceeds 5 years", "broad definition"],
        "description": "Perpetual obligations create ongoing compliance burden"
    },
    "non_compete": {
        "high_risk": ["worldwide non-compete", "non-compete exceeds 24 months", "industry-wide restriction"],
        "medium_risk": ["regional non-compete", "12-24 month restriction"],
        "description": "Overly broad non-competes limit future business"
    },
    "audit_rights": {
        "high_risk": ["unlimited audit rights", "audit at any time", "audit without notice"],
        "medium_risk": ["audit more than annually", "broad audit scope"],
        "description": "Excessive audit rights create operational burden"
    },
    "governing_law": {
        "high_risk": ["foreign jurisdiction", "arbitration in buyer's jurisdiction only"],
        "medium_risk": ["distant jurisdiction", "waive jury trial"],
        "description": "Unfavorable venue increases dispute costs"
    }
}

def init_db():
    """Initialize SQLite database for metrics and learning."""
    os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS analyses (
            id INTEGER PRIMARY KEY,
            timestamp DATETIME,
            doc_type TEXT,
            text_length INTEGER,
            findings_count INTEGER,
            overall_risk TEXT,
            duration_ms INTEGER,
            success INTEGER
        )
    """)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS corrections (
            id INTEGER PRIMARY KEY,
            analysis_id INTEGER,
            clause_id TEXT,
            original_severity TEXT,
            corrected_severity TEXT,
            is_correct INTEGER,
            timestamp DATETIME
        )
    """)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS learned_patterns (
            id INTEGER PRIMARY KEY,
            pattern TEXT UNIQUE,
            severity TEXT,
            category TEXT,
            source TEXT,
            confidence REAL,
            created_at DATETIME,
            updated_at DATETIME
        )
    """)
    conn.commit()
    conn.close()

init_db()

# Request/Response Models
class AnalyzeRequest(BaseModel):
    document_id: Optional[str] = None
    doc_type: Optional[str] = "unknown"
    text: str
    tenant_id: Optional[str] = "default"
    policy_context: Optional[Dict[str, Any]] = None

class CorrectionRequest(BaseModel):
    analysis_id: Optional[int] = None
    clause_id: str
    detection_text: str
    original_severity: str
    is_correct: bool
    corrected_severity: Optional[str] = None

class Finding(BaseModel):
    id: str
    category: str
    severity: str  # red, yellow, green
    clause_text: str
    explanation: str
    recommendation: str
    redline_suggestion: Optional[str] = None
    confidence: float

class AnalyzeResponse(BaseModel):
    document_id: str
    overall_risk: str  # red, yellow, green
    summary: str
    findings: List[Finding]
    redlines: List[Dict[str, str]]
    category_scores: Dict[str, str]
    confidence: float
    processing_time_ms: int

# Claude API Integration
async def analyze_with_claude(text: str, doc_type: str, policy_context: Optional[Dict] = None) -> Dict:
    """Call Claude API for contract analysis."""

    if not ANTHROPIC_API_KEY:
        raise HTTPException(status_code=500, detail="ANTHROPIC_API_KEY not configured")

    system_prompt = """You are a contract risk analyst evaluating agreements FROM THE SUPPLIER'S PERSPECTIVE.
Your job is to identify clauses that are unfavorable, risky, or one-sided against the supplier.

For each problematic clause found, assess:
1. Severity: RED (unacceptable risk), YELLOW (negotiate), GREEN (acceptable)
2. Category: payment_terms, indemnification, limitation_of_liability, termination, ip_rights, warranty, confidentiality, non_compete, audit_rights, governing_law
3. Specific risk to the supplier
4. Recommended redline language

Respond ONLY with valid JSON in this exact format:
{
    "overall_risk": "red|yellow|green",
    "summary": "2-3 sentence executive summary",
    "findings": [
        {
            "id": "unique_id",
            "category": "category_name",
            "severity": "red|yellow|green",
            "clause_text": "exact quote from contract",
            "explanation": "why this is problematic for supplier",
            "recommendation": "accept|negotiate|reject",
            "redline_suggestion": "suggested replacement language or null",
            "confidence": 0.0-1.0
        }
    ],
    "category_scores": {
        "payment_terms": "red|yellow|green|not_found",
        "indemnification": "red|yellow|green|not_found",
        "limitation_of_liability": "red|yellow|green|not_found",
        "termination": "red|yellow|green|not_found",
        "ip_rights": "red|yellow|green|not_found",
        "warranty": "red|yellow|green|not_found",
        "confidentiality": "red|yellow|green|not_found",
        "non_compete": "red|yellow|green|not_found",
        "audit_rights": "red|yellow|green|not_found",
        "governing_law": "red|yellow|green|not_found"
    },
    "redlines": [
        {"original": "problematic text", "suggested": "improved text", "priority": "high|medium|low"}
    ],
    "confidence": 0.0-1.0
}"""

    user_prompt = f"""Analyze this {doc_type} contract from the SUPPLIER'S perspective.
Identify all clauses that create risk, liability, or unfavorable terms for the supplier.

CONTRACT TEXT:
{text[:15000]}

{"POLICY CONTEXT: " + json.dumps(policy_context) if policy_context else ""}

Return your analysis as JSON only."""

    async with httpx.AsyncClient(timeout=120.0) as client:
        response = await client.post(
            "https://api.anthropic.com/v1/messages",
            headers={
                "x-api-key": ANTHROPIC_API_KEY,
                "anthropic-version": "2023-06-01",
                "content-type": "application/json"
            },
            json={
                "model": "claude-sonnet-4-20250514",
                "max_tokens": 4096,
                "system": system_prompt,
                "messages": [{"role": "user", "content": user_prompt}]
            }
        )

        if response.status_code != 200:
            raise HTTPException(status_code=response.status_code, detail=f"Claude API error: {response.text}")

        result = response.json()
        content = result["content"][0]["text"]

        # Parse JSON from response
        try:
            # Handle potential markdown code blocks
            if "```json" in content:
                content = content.split("```json")[1].split("```")[0]
            elif "```" in content:
                content = content.split("```")[1].split("```")[0]
            return json.loads(content.strip())
        except json.JSONDecodeError as e:
            raise HTTPException(status_code=500, detail=f"Failed to parse Claude response: {str(e)}")

# API Endpoints
@app.get("/health")
def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "service": "contract-intelligence",
        "version": "1.0.0",
        "timestamp": datetime.now().isoformat(),
        "api_configured": bool(ANTHROPIC_API_KEY)
    }

@app.post("/api/v1/analyze", response_model=AnalyzeResponse)
async def analyze_contract(request: AnalyzeRequest):
    """
    Analyze contract text and return stoplight risk assessment.

    Returns findings with severity (red/yellow/green), explanations,
    and suggested redline changes from supplier perspective.
    """
    start_time = datetime.now()

    if not request.text or len(request.text.strip()) < 50:
        raise HTTPException(status_code=400, detail="Contract text too short for analysis")

    try:
        # Call Claude for analysis
        analysis = await analyze_with_claude(
            text=request.text,
            doc_type=request.doc_type,
            policy_context=request.policy_context
        )

        duration_ms = int((datetime.now() - start_time).total_seconds() * 1000)

        # Log to database
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.execute(
            """INSERT INTO analyses
               (timestamp, doc_type, text_length, findings_count, overall_risk, duration_ms, success)
               VALUES (?, ?, ?, ?, ?, ?, ?)""",
            (datetime.now().isoformat(), request.doc_type, len(request.text),
             len(analysis.get("findings", [])), analysis.get("overall_risk", "unknown"),
             duration_ms, 1)
        )
        analysis_id = cursor.lastrowid
        conn.commit()
        conn.close()

        # Build response
        return AnalyzeResponse(
            document_id=request.document_id or str(analysis_id),
            overall_risk=analysis.get("overall_risk", "yellow"),
            summary=analysis.get("summary", "Analysis complete"),
            findings=[Finding(**f) for f in analysis.get("findings", [])],
            redlines=analysis.get("redlines", []),
            category_scores=analysis.get("category_scores", {}),
            confidence=analysis.get("confidence", 0.8),
            processing_time_ms=duration_ms
        )

    except HTTPException:
        raise
    except Exception as e:
        # Log failure
        conn = sqlite3.connect(DB_PATH)
        conn.execute(
            """INSERT INTO analyses
               (timestamp, doc_type, text_length, findings_count, overall_risk, duration_ms, success)
               VALUES (?, ?, ?, ?, ?, ?, ?)""",
            (datetime.now().isoformat(), request.doc_type, len(request.text), 0, "error", 0, 0)
        )
        conn.commit()
        conn.close()
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/v1/correct")
async def submit_correction(request: CorrectionRequest):
    """
    Submit correction feedback for learning.

    Used when user marks a detection as correct/incorrect,
    enabling the system to improve over time.
    """
    conn = sqlite3.connect(DB_PATH)

    # Log correction
    conn.execute(
        """INSERT INTO corrections
           (analysis_id, clause_id, original_severity, corrected_severity, is_correct, timestamp)
           VALUES (?, ?, ?, ?, ?, ?)""",
        (request.analysis_id, request.clause_id, request.original_severity,
         request.corrected_severity, 1 if request.is_correct else 0, datetime.now().isoformat())
    )

    # If correction provided, learn the pattern
    if not request.is_correct and request.corrected_severity:
        # Update or insert learned pattern
        conn.execute(
            """INSERT INTO learned_patterns (pattern, severity, category, source, confidence, created_at, updated_at)
               VALUES (?, ?, ?, 'user_correction', 0.9, ?, ?)
               ON CONFLICT(pattern) DO UPDATE SET
               severity = excluded.severity,
               confidence = MIN(1.0, confidence + 0.1),
               updated_at = excluded.updated_at""",
            (request.detection_text[:500], request.corrected_severity, request.clause_id,
             datetime.now().isoformat(), datetime.now().isoformat())
        )

    conn.commit()
    conn.close()

    return {
        "status": "correction_recorded",
        "clause_id": request.clause_id,
        "learning_applied": not request.is_correct and request.corrected_severity is not None
    }

@app.get("/api/v1/patterns")
def get_patterns():
    """
    Get current risk pattern library.

    Returns both built-in patterns and learned patterns from corrections.
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.execute(
        "SELECT pattern, severity, category, confidence FROM learned_patterns ORDER BY confidence DESC LIMIT 100"
    )
    learned = [{"pattern": r[0], "severity": r[1], "category": r[2], "confidence": r[3]} for r in cursor.fetchall()]
    conn.close()

    return {
        "builtin_patterns": RISK_PATTERNS,
        "learned_patterns": learned,
        "total_learned": len(learned)
    }

@app.get("/api/v1/metrics")
def get_metrics():
    """Get service performance metrics."""
    conn = sqlite3.connect(DB_PATH)

    # Overall stats
    cursor = conn.execute("""
        SELECT
            COUNT(*) as total,
            SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful,
            AVG(duration_ms) as avg_duration,
            AVG(findings_count) as avg_findings
        FROM analyses
        WHERE timestamp > datetime('now', '-24 hours')
    """)
    row = cursor.fetchone()

    # Risk distribution
    cursor = conn.execute("""
        SELECT overall_risk, COUNT(*)
        FROM analyses
        WHERE success = 1 AND timestamp > datetime('now', '-7 days')
        GROUP BY overall_risk
    """)
    risk_dist = {r[0]: r[1] for r in cursor.fetchall()}

    # Correction stats
    cursor = conn.execute("SELECT COUNT(*), SUM(is_correct) FROM corrections")
    corr_row = cursor.fetchone()

    conn.close()

    return {
        "period": "24h",
        "total_analyses": row[0] or 0,
        "successful": row[1] or 0,
        "avg_duration_ms": round(row[2] or 0, 2),
        "avg_findings_per_doc": round(row[3] or 0, 1),
        "success_rate": round((row[1] / row[0] * 100) if row[0] else 100, 1),
        "risk_distribution_7d": risk_dist,
        "corrections": {
            "total": corr_row[0] or 0,
            "confirmed_correct": corr_row[1] or 0
        }
    }

@app.get("/api/v1/revisions")
def get_revisions():
    """Get recent analysis revisions/history."""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.execute("""
        SELECT id, timestamp, doc_type, findings_count, overall_risk, duration_ms
        FROM analyses
        WHERE success = 1
        ORDER BY timestamp DESC
        LIMIT 50
    """)
    revisions = [
        {
            "id": r[0],
            "timestamp": r[1],
            "doc_type": r[2],
            "findings_count": r[3],
            "overall_risk": r[4],
            "duration_ms": r[5]
        }
        for r in cursor.fetchall()
    ]
    conn.close()

    return {"revisions": revisions, "total": len(revisions)}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=int(os.environ.get("PORT", 8002)))
